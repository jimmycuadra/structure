{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","body":"# Structure\r\n\r\n**Structure** is a small library that encourages developers to better organize their client-side JavaScript code. It offers a single global variable under which an application's code should be contained, the ability to create namespaces under that global variable, and the ability to register reusable modules.\r\n\r\n## Usage\r\n\r\nInclude `structure.min.js` with a script tag. Although you can use `Structure` itself as your global namespace, you're encouraged to pick a name for your application. These examples will simply use `App`.\r\n\r\n``` javascript\r\nStructure.init(\"App\");\r\n```\r\n\r\nThe above call will remove `Structure` from the global namespace and re-add it as `App`.\r\n\r\n### Structure.registerModule\r\n\r\nThe `registerModule` method is used for generating namespaced modules. The first argument is a string representing the namespaces and module you're defining. If only one argument is passed, the module is created as an empty object.\r\n\r\n``` javascript\r\nApp.registerModule(\"App.Views.Comment\");\r\n\r\nApp.Views.Comment; // empty object\r\n```\r\n\r\nTo populate the module in one shot, pass an object literal as the second argument.\r\n\r\n``` javascript\r\nApp.registerModule(\"App.Views.Comment\", {\r\n  validate: function (comment) {\r\n    return comment.name.length > 0 && comment.body.length > 0;\r\n  }\r\n});\r\n\r\nApp.Views.Comment.validate({ name: \"Joe\", body: \"Great post!\" }); // true\r\n```\r\n\r\nStructure will automatically *bind* all the functions in your module so that the value of `this` inside each method refers to the module itself.\r\n\r\n``` javascript\r\nApp.registerModule(\"App.Examples.Binding\", {\r\n  one: function () {\r\n    return this.two;\r\n  },\r\n\r\n  two: \"woo!\"\r\n});\r\n\r\n// Using a module's method as a jQuery event handler\r\n$(document.body).on(\"example\", App.Examples.Binding.one);\r\n$(document.body).trigger(\"example\"); // \"woo!\"\r\n```\r\n\r\n`registerModule` also takes an optional callback function as a third parameter. This callback will be passed the newly registered module, so you can conveniently wire up your module's methods to elements/events in the DOM without having to reference the full namespace.\r\n\r\n``` javascript\r\nApp.registerModule(\"App.Form\", {\r\n  onClick: function (event) {\r\n    // Do something with a click event\r\n  },\r\n\r\n  onSubmit: function (event) {\r\n    // Do something with a submit event\r\n  }\r\n}, function (module) {\r\n  var form = $(\"form\");\r\n\r\n  form.on(\"click\", module.onClick);\r\n  form.on(\"submit\", module.onSubmit);\r\n});\r\n```\r\n\r\n## Advantages\r\n\r\nWhile these simple examples may make it seem that Structure is unnecessary boilerplate, there are advantages to this approach.\r\n\r\nAs your application grows, it's easier to maintain code when chunks of functionality are grouped into modules in an organized way. This organization also aids in understanding the system for new developers working on an existing code base (or the original developers trying to remember the purpose of some code they wrote months or years ago.)\r\n\r\nPutting methods in named properties helps communicate what they do. This is often not immediately clear if all of your application's behavior is inside anonymous functions passed to jQuery event binding functions. Should you decide to unit test your code (which you should), being able to reference individual methods this way is basically required.\r\n\r\n## Further reading\r\n\r\nStructure was inspired by my blog post, [jQuery is not an architecture](http://jimmycuadra.com/posts/jquery-is-not-an-architecture).\r\n","name":"Structure","tagline":"Add some basic structure to your client-side JavaScript."}